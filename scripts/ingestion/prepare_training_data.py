"""
TRAINING DATA PREPARATION & SANITIZATION
========================================
Prepares the raw industrial symbiosis data for various AI training workflows.
1. Sanitizes text (normalization, cleaning)
2. Generates Fine-tuning data (Chat format)
3. Generates Pre-training data (Raw corpus)
4. Generates Graph data (Link prediction)
"""
import json
import csv
import re
import unicodedata
import psycopg2
from pathlib import Path
from config import POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_HOST, POSTGRES_PORT

OUTPUT_DIR = Path("data/training")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

def clean_text(text):
    if not text:
        return ""
    # Normalize unicode
    text = unicodedata.normalize('NFKC', text)
    # Remove control characters
    text = "".join(ch for ch in text if unicodedata.category(ch)[0] != "C" or ch in ["\n", "\t"])
    # Normalize whitespace
    text = re.sub(r'\s+', ' ', text).strip()
    return text

def prepare_data():
    conn = psycopg2.connect(dbname=POSTGRES_DB, user=POSTGRES_USER, password=POSTGRES_PASSWORD, host=POSTGRES_HOST, port=POSTGRES_PORT)
    cur = conn.cursor()
    
    print("Fetching data from database...")
    
    # 1. Fetch Material Profiles (Rich knowledge)
    print("   Fetching material profiles...")
    cur.execute("""
        SELECT material, material_category, total_quantity, avg_purity, source_industries, compatible_receivers
        FROM (
            SELECT 
                material,
                material_category,
                SUM(quantity_tons) as total_quantity,
                AVG(purity_percentage) as avg_purity,
                STRING_AGG(DISTINCT source_industry, ', ') as source_industries,
                'Unknown' as compatible_receivers -- placeholder for now
            FROM waste_listings
            GROUP BY material, material_category
        ) sub
        WHERE total_quantity > 0
    """)
    profiles = cur.fetchall()
    
    # 2. Fetch Symbiosis Matches (Logic/Reasoning)
    print("   Fetching symbiosis matches...")
    # Logic to pair generators with potential receivers (simplified for now based on category)
    cur.execute("""
        SELECT 
            w1.source_company as generator,
            w1.material,
            w1.quantity_tons,
            w1.source_location,
            w1.material_category
        FROM waste_listings w1
        WHERE w1.quantity_tons > 10
    """)
    listings = cur.fetchall()
    
    # --- EXPORT 1: PRE-TRAINING CORPUS (Raw Text) ---
    print(f"Generating Pre-training Corpus ({len(listings)} listings, {len(profiles)} profiles)...")
    with open(OUTPUT_DIR / "symbio_corpus_v1.txt", "w", encoding="utf-8") as f:
        # Write profiles as encyclopedic entries
        for p in profiles:
            mat, cat, qty, purity, inds, _ = p
            text = f"Material Profile: {clean_text(mat)}\nCategory: {clean_text(cat)}\n"
            text += f"Total Available Quantity: {qty:,.2f} tons\n"
            text += f"Typical Sources: {clean_text(inds)}\n"
            text += f"Description: {clean_text(mat)} is a material in the {clean_text(cat)} category, commonly generated by {clean_text(inds)}.\n\n"
            f.write(text)
        
        # Write listings as raw observations
        for l in listings:
            gen, mat, qty, loc, cat = l
            text = f"Industrial Waste Listing: {clean_text(gen)} in {clean_text(loc)} has generated {qty:,.2f} tons of {clean_text(mat)} ({cat}).\n"
            f.write(text)

    # --- EXPORT 2: FINE-TUNING DATA (Chat/Instruction) ---
    print("Generating Fine-tuning Dataset (JSONL)...")
    qa_pairs = []
    
    # Task: Material Classification
    for p in profiles:
        mat, cat, _, _, inds, _ = p
        cat = cat or "Industrial Waste"
        inds = inds or "General Industry"
        if mat:
            qa_pairs.append({
                "messages": [
                    {"role": "user", "content": f"Categorize the industrial waste stream: {clean_text(mat)}"},
                    {"role": "assistant", "content": f"{clean_text(mat)} is classified as {clean_text(cat)}. It is typically generated by industries such as {clean_text(inds)}."}
                ]
            })
            
    # Task: Matchmaking Recommendation (Synthetic based on rules)
    for l in listings:
        gen, mat, qty, loc, cat = l
        cat = cat or "Industrial Waste"
        if mat:
            # Simple rule-based logic for training example
            receiver_type = "Recycling Facility"
            if "organic" in str(cat).lower() or "food" in mat.lower(): receiver_type = "Composting Facility or Biogas Plant"
            elif "metal" in str(cat).lower() or "zinc" in mat.lower(): receiver_type = "Metal Smelter or Foundry"
            elif "plastic" in str(cat).lower() or "polymer" in mat.lower(): receiver_type = "Plastic Reprocessor"
            elif "hazardous" in str(cat).lower() or "toxic" in mat.lower(): receiver_type = "Hazardous Waste Incinerator"
            
            qa_pairs.append({
                "messages": [
                    {"role": "user", "content": f"Suggest a symbiosis partner for {qty} tons of {clean_text(mat)} in {clean_text(loc)}."},
                    {"role": "assistant", "content": f"For {clean_text(mat)} ({cat}), a suitable partner would be a {receiver_type}. The material is located in {clean_text(loc)}, so local partners should be prioritized to reduce transport emissions."}
                ]
            })
            
    with open(OUTPUT_DIR / "symbio_chat_finetune_v1.jsonl", "w", encoding="utf-8") as f:
        for pair in qa_pairs:
            f.write(json.dumps(pair) + "\n")

    # --- EXPORT 3: KNOWLEDGE GRAPH (Nodes/Edges) ---
    print("Generating Knowledge Graph Edges...")
    with open(OUTPUT_DIR / "symbio_graph_edges.csv", "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["source_node", "relation", "target_node", "weight"])
        
        for l in listings:
            gen, mat, qty, loc, cat = l
            if gen and mat:
                writer.writerow([clean_text(gen), "GENERATES", clean_text(mat), float(qty)])
            if mat and cat:
                writer.writerow([clean_text(mat), "IS_CATEGORY", clean_text(cat), 1.0])
            if gen and loc:
                writer.writerow([clean_text(gen), "LOCATED_IN", clean_text(loc), 1.0])

    print("\nDONE! Training data ready in data/training/")
    print(f"   - Corpus: {OUTPUT_DIR / 'symbio_corpus_v1.txt'}")
    print(f"   - Fine-tune: {OUTPUT_DIR / 'symbio_chat_finetune_v1.jsonl'} ({len(qa_pairs)} examples)")
    print(f"   - Graph: {OUTPUT_DIR / 'symbio_graph_edges.csv'}")

if __name__ == "__main__":
    prepare_data()
